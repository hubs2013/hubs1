# -*-encoding=utf8-*-
# import numpy
# import jieba
# # str='如果你现在检查图表，会感觉比之前那张图标更加清晰，因为没有了停止词的干扰。'
# # jieba.add_word("停止词")#在jieba库中添加停用词
# # jl=jieba.cut(str,cut_all=False)#以长词分为准
# # jl2=jieba.cut(str,cut_all=True)#长词再细分
# # strlist='/'.join(jl)
# # strlist2='/'.join(jl2)
# # print(strlist)
# # print(strlist2)
#
#
# # str="Hello Adam, how are you? I hope everything is going well.  Today is a good day, see you dude."
#
# # import nltk
# # from nltk import tokenize
# # from nltk import punkt
# # fenci=tokenize.sent_tokenize(str)
# # print(str.split())
#
# from stanfordcorenlp import StanfordCoreNLP
#
# nlp = StanfordCoreNLP('E:/program/stanfordnlp/stanfordnlp', lang='zh')
# print(nlp.lang)
# str="一分钟了解动态人脸识别技术电子发烧友网人脸识别几乎在一夜之间，“人脸识别”成为科技行业炙手可热的名词，其百度指数从年初的飙升到最高达。除了的横空出世带来的市场效应之外，根本的原因是随着这项技术逐渐成熟，应用领域的拓宽带来了行业发展，从事相关技术研究的公司也在今年喷涌浮现。一分钟了解动态人脸识别技术几乎在一夜之间，“人脸识别”成为科技行业炙手可热的名词，其百度指数从年初的飙升到最高达。除了的横空出世带来的市场效应之外，根本的原因是随着这项技术逐渐成熟，应用领域的拓宽带来了行业发展，从事相关技术研究的公司也在今年喷涌浮现。百度广告样式用户头像用户头像专家问答主体内容一分钟了解动态人脸识别技术发表于收藏已收藏赞（）评论（）赞评论分享●●●专家问答主体内容专家问答文章详情赞（）评论（）赞评论分享评论分享收藏一分钟了解动态人脸识别技术发表于作者头像电子发烧友网工程师聚丰关注专栏部分文章来源栏目触控感测关注人关注几乎在一夜之间，人脸识别成为科技行业炙手可热的名词，其百度指数从年初的飙升到最高达。除了的横空出世带来的市场效应之外，根本的原因是随着这项技术逐渐成熟，应用领域的拓宽带来了行业发展，从事相关技术研究的公司也在今年喷涌浮现。上周，从事人脸识别、物体识别、车辆识别等技术研发的人工智能大数据公司深圳神目，正式对外宣布完成来自深创投旗下国中创投数千万美元轮融资，据负责人介绍，资金将主要投入项目的深度研发，同时开拓市场，建立公司品牌。荒合资本在本次交易中担任神目的独家财务顾问。一分钟了解动态人脸识别技术究竟是一家怎样的公司，可以获得国字头创投机构的如此青睐？联合海内外技术团队专注计算机视觉算法研究神目创始人刘靖峰，一位从硅谷归来的光谷创业者。毕业于美国卡内基梅隆大学电子与计算机工程博士，美国荣誉科学家协会（）会员，更在年入选国家第七批千人计划国家特聘专家。年，刘靖峰带领团队回国，在武汉创立了神目公司的前身：联思普瑞电子科技，成功研发智能电网电力载波通讯主控片的系统芯片，并很快将其产业化。在项目实践过程中，团队逐渐摸索人脸及物体识别技术，发现了一片更广阔的天地。于是在年，刘靖峰带领来自卡内基梅隆大学、密执安州立大学、俄克拉荷马大学、清华大学、浙江大学等中美一流高校的人工智能博士团队，创立了专注计算机视觉的人工智能大数据公司神目（），致力于研究人脸识别技术算法。同时联合卡内基梅隆大学联合成立生物识别研究室，并成为美国国家自然基金（）旗下创始会员。刘靖峰博士不仅具有深厚的学术与科研积累，对中美两国乃至全球的行业格局也有全面的理解和规划。作为联思普瑞和神目的天使投资机构，合力投资向记者表达了对刘博士的能力和视野的全方位肯定，这也正是合力的投资初心。据介绍，自创立以来，神目一直专注于计算机视觉识别领域各类算法的研究，在人脸特征提取引擎技术、姿态识别技术、物体识别与图像分类、识别等技术算法上达到行业领先水平，在业内首创了遮挡面部还原，模糊人脸还原，大姿势人脸识别等行业多项领先技术，自建万张深度摄像头人脸数据库，其模型训练效率是同类产品的倍，模型泛化能力更是遥遥领先行业平均水平。一分钟了解动态人脸识别技术正因为这份对算法技术的专注，神目在今年迎来了高速发展，不仅为各行业成功输出高效的技术解决方案，也获得了投资机构的一致看好。神目智慧城市解决方案人脸识别技术目前应用广泛，国内近年最大的应用尝试在公共安全领域。据神目智慧城市项目负责人介绍，神目的遮挡面部还原，低分辨率、大姿势人脸识别，二维人脸图像生成人脸模型等技术处于全球领先水平。由神目算法支持的摄像头可以识别大姿势下的人脸，在仰头低头，左右转头最大度以内，甚至侧歪度时，都可以正确识别。对于被遮挡的人脸，最少露出就可以完成识别，甚至可以通过眼睛周边细节还原人脸特征，进行人脸匹配。针对公共安防领域的视频数据结构化、业务智能化需求，神目为公安系统专门开发了基于深度学习模型的动态人脸识别系统，提供包括人物布控、人物轨迹回放、电子信息和人脸特征碰撞等一系列公共安全解决方案。这些解决方案，支持现有平安城市已经建设的摄像头（米或者米杆体安装）进行人脸检测与识别，提高公安整体联动水平和快速处理能力，减少警务成本。由于不需要对摄像头做调整，神目产品可以将已有历史视频数据做结构化，协助警方快速侦破案件，有效支撑智慧安防、智能警务的发展目标。目前神目产品已在国内多地公安系统内得到应用。神目在新零售等各个领域的拓展针对市场需求，神目已将人脸识别、物体识别、车辆识别等人工智能技术在智慧城市、智慧旅游、智慧医疗、移动终端领域进行应用实践。其中专门为手机深度摄像头打造的深度学习模型，通过自有的算法研发能力和在手机终端上持续优化能力，已开发出人脸解锁（带活体），以及智能相册分类产品，并成功出货到二三线品牌应用，已累计出货万台。神目在美国已经成功拿下万家便利店、商超及银行网店的内部安防及客流数据分析摄像头订单，保护店内安全，并对消费者数据进行采集。尤其在安防方面，半年多来，神目在美国已经积累了超过万惯偷的云端数据库，一旦摄像头发现可疑人物，系统将会识别并发出预警，提醒店员适当关注，预计每年可为每家店节省万美金。一分钟了解动态人脸识别技术在国内新零售领域，神目也有很多进展。在某大型商业广场入口顶部架设台摄像头，分别对大门左右两侧进行实时人脸捕捉，对进店客流量、顾客性别、年龄段统计、客户识别等进行统计与分析，为商场活动规划、策划效果评估提供新一代大数据支持。神目一直以来都遵循以应用和市场需求为导向，再去寻找相应的技术解决方案。零售行业的项目负责人告诉记者，目前在新零售领域的需求点很多，可做的产品也很多，特别是将人脸识别技术与无人商店概念相结合的产品和解决方案是神目未来几年的发展重点之一。当消费者进入商店第一次时间，摄像头就能识别消费者信息，并根据消费者姿势体态分析消费者兴趣爱好，同时对消费者购物篮中的物品进行自动识别，消费者在走出商场时自动刷脸完成付款动作。随着人脸识别技术应用领域的不断拓宽，神目作为上游算法技术方案输出方，未来在技术研发及大数据积累上依然任重而道远。神目创始人表示，公司在新的资金注入以后，将联合更多海内外技术团队进行更深层面的技术研发，以市场需求为导向，专注为各行业不断提供更优质高效可行的技术解决方案。一分钟了解动态人脸识别技术几乎在一夜之间，“人脸识别”成为科技行业炙手可热的名词，其百度指数从年初的飙升到最高达。除了的横空出世带来的市场效应之外，根本的原因是随着这项技术逐渐成熟，应用领域的拓宽带来了行业发展，从事相关技术研究的公司也在今年喷涌浮现。编辑器内容编辑器内容相关推荐：龙哥教你天学会人脸识别天学会人脸识别设计挑战赛调用实现人脸识别子封装声明：本文由入驻电子说专栏的作者撰写或者网上转载，观点仅代表作者本人，不代表电子发烧友网立场。如有侵权或者其他问题，请联系举报。侵权投诉如果是已经点了赞赞收藏相关话题人脸识别人脸识别人脸识别关注未关注已关注评论加载更多评论登录后参与评论广告广告专栏部分相关文章如果没有图片就不要这块如果没有图片就不要这块龙哥教你天学会人脸识别发烧友学院如果没有图片就不要这块如果没有图片就不要这块人脸识别有哪些利与弊次阅读如果没有图片就不要这块如果没有图片就不要这块将向用户提示有关人脸识别功能的信息次阅读如果没有图片就不要这块如果没有图片就不要这块表示将不会默认开启人脸识别功能，被罚怕了？次阅读如果没有图片就不要这块如果没有图片就不要这块年至年，人工智能行业复合增长率将达到次阅读如果没有图片就不要这块如果没有图片就不要这块宿舍门前装上人脸识别系统，扔垃圾需提前分类！次阅读如果没有图片就不要这块如果没有图片就不要这块法律职业资格考试，聊城考区引入人脸识别技术防作弊次阅读如果没有图片就不要这块如果没有图片就不要这块商品识别在零售行业的应用，商品识别的难点次阅读如果没有图片就不要这块如果没有图片就不要这块科技嘉年华在上海世博展览馆中厅舞台区精彩上演次阅读如果没有图片就不要这块如果没有图片就不要这块或将步前辈短命后尘，“换脸”已形成黑色产业链次阅读如果没有图片就不要这块如果没有图片就不要这块人工智能国家队中科视拓宣布，开源商用级人脸识别算法次阅读如果没有图片就不要这块如果没有图片就不要这块内外结合预防保障生物识别信息安全次阅读如果没有图片就不要这块如果没有图片就不要这块“双马”对话成焦点，人与机器谁更聪明？次阅读如果没有图片就不要这块如果没有图片就不要这块想要保护人脸信息反人脸识别技术来助力次阅读如果没有图片就不要这块如果没有图片就不要这块人脸识别技术发展迅速但也带来了很大的风险次阅读如果没有图片就不要这块如果没有图片就不要这块人脸识别系统定位功能剖析次阅读百度分享分享到分享到空间空间分享到好友好友分享到新浪微博微博百度分享取消微信分享图片地址微信分享图片地址新版统计百度统计判断是否微信浏览器添加广告链接的事件跟踪微信浏览器底部显示关注微信路障广告弹窗广告点击关闭关闭路障广告设置函数是否是从电路图过来的做处理点击评论跳转到评论区域获得二级域名点击取消或者关注返回的数据格式：已关注关注点击专栏取消或者关注已关注返回的数据格式：已关注关注已关注点击栏目取消或者关注返回的数据格式：已关注人关注底部的评论分享收藏，页面下滑的时候出现，上滑的时候消失获取初始滚动高度新的滚动高度判断滚动方向没有分享图片的时候传默认在微信中使用微信自己的分享定义默认的微信分享信息，页面如果要自定义分享，直接更改此变量即可标题描述分享图标默认是链接分享类型、或，不填默认为如果是或，则要提供数据链接，默认为空用户确认分享后执行的回调函数用户取消分享后执行的回调函数开启调试模式调用的所有的返回值会在客户端出来，若要查看传入的参数，可以在端打开，参数信息会通过打出，仅在端时才会打印。必填，公众号的唯一标识必填，生成签名的时间戳必填，生成签名的随机串必填，签名，见附录必填，需要使用的接口列表，所有接口列表见附录获取“分享到朋友圈”按钮点击状态及自定义分享内容接口分享标题分享链接分享图标用户确认分享后执行的回调函数用户取消分享后执行的回调函数获取“分享给朋友”按钮点击状态及自定义分享内容接口分享标题分享描述分享链接分享图标分享类型、或，不填默认为如果是或，则要提供数据链接，默认为空用户确认分享后执行的回调函数用户取消分享后执行的回调函数获取“分享到”按钮点击状态及自定义分享内容接口分享标题分享描述分享链接分享图标用户确认分享后执行的回调函数用户取消分享后执行的回调函数获取“分享到腾讯微博”按钮点击状态及自定义分享内容接口分享标题分享描述分享链接分享图标用户确认分享后执行的回调函数用户取消分享后执行的回调函数获取“分享到空间”按钮点击状态及自定义分享内容接口分享标题分享描述分享链接分享图标用户确认分享后执行的回调函数用户取消分享后执行的回调函数新增广告位芯城广告发烧友增加百度统计自定义变量统计单一用户数据访问量发烧友学院发烧友学院"
# test=nlp.ner(str)
# tes=open("tes.txt","w",encoding='utf8')
# tes.write(" ".join([each[0] + "/" + each[1] for each in test ])+ "\n")
# print(len(test)




# list=[3,4,4,3,2,99,2,5,5,12]
# res=0
# for i in list:
#     res=i^res
# print(bin(res))
# fi_1=bin(3)[::-1].index("1")
# list1=[]
# list2=[]
# for i in list:
#     if bin(i)[::-1][fi_1]=="1":
#         list1.append(i)
#     else:
#         list2.append(i)
# for i in list1:
#     res=i^res
# print(res)

# for i in list2:
#     res=i^res
# print(res)
#
# print(list1)
# print(list2)
#
# # 寻找第N个丑数，思路：选用三指针的方法，依次增加下一个丑数
# def find_ugly_number(index):
#     if index==1:
#         return 1
#     ugly_number=[1]
#     two_pointer=0
#     three_pointer=0
#     five_pointer=0
#     i=2
#     count=1
#     while True:
#         two_res=ugly_number[two_pointer]*2
#         three_res=ugly_number[three_pointer]*3
#         five_res=ugly_number[five_pointer]*5
#         insert_number=min(two_res,three_res,five_res)
#         ugly_number.append(insert_number)
#         count+=1
#         if count==index:
#                 return insert_number
#         if insert_number==two_res:
#                 two_pointer+=1
#         if insert_number==three_res:
#                 three_pointer+=1
#         if insert_number==five_res:
#                 five_pointer+=1
#         i+=1
#
# print(find_ugly_number(1))



# n=int(input("please input n:"))
# max=int("9"*n)
# list=[str(i) for i in range(1,max+1)]
# # print(list[100])
# print(list[max-1])


#顺子
# import random
# list=list(range(1,14))
# list.extend(["x","y"])
# # print(list)
# out2=random.choice(list)
# print('随机一张:',out2)
# random.shuffle(list)
# print(list)


#给定一个数组，求出能拼接成的最小数
# arr=[32,222,22,2]#121123213232这是最小的数
# arr=sorted(arr,reverse=True)
# print(arr)
# max_len=max([len(str(i)) for i in arr])
# nex_arr=[int(str(i)+(str(i)[0])*(max_len-len(str(i)))) for i in arr]
# nex_arr2=sorted(nex_arr)
# res=""
# for i in range(len(nex_arr2)):
#     res+=str(arr[nex_arr.index(nex_arr2[i])])
#     nex_arr[nex_arr.index(nex_arr2[i])]=0
#
# print(res)


# 题目：输入一个字符串，输出该字符串中对称的子字符串的最大长度。
# 比如输入字符串“google”，由于该字符串里最长的对称子字符串是“goog”，因此输出4

# import string
# str='google'
# s=string.ascii_letters
# # print(s)
# chstr=[s.index(i) for i in str]
# v=[ord(i) for i in str]  #另一种方法
# print(v)
# print(chstr)
#
# def find_max_pubstr(chstr):
#     for i in  range(len(chstr)-1):
#         for j in range(i+1,len(chstr)):
#             nstr=chstr[i:j]
#             ystr=str[i:j]
#             zt=0
#             for k in nstr:
#                 zt=zt^k
#             if zt==0:
#                 yield ystr,len(nstr)
# def out_length(object):
#     # max_len=max(map(lambda x:x[1],object))
#     # print(type(max_len))
#     # print(max_len)
#     out_str=filter(lambda x:x[1]==4,object)
#     # print(out_str)
#     return out_str
#
# object=find_max_pubstr(chstr)
# # print( list(find_max_pubstr(chstr) ))
# print(list(out_length(object)))
#
#
# def find_max(str):
#     list=[ord(i) for i in str]
#     maxt = 1
#     for i in range(len(list)):
#         res=list[i]
#         for j in range(len(list[i+1:])):
#             res=res^list[i+1:][j]
#             if res==0:
#                 maxt=max(maxt,j+2)
#     return maxt
#
# print(find_max(str))





# 数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。
# list=[2,2,3,4,5,3,2,2,2,3,5,2,2,2]
# def find_number(list):
#     # print(len(list))
#     before_list=sorted(list)[:int(len(list)/2)]
#     after_list=sorted(list)[int(len(list)/2):]
#     if before_list[0]==before_list[-1]:
#         return before_list[0]
#     if after_list[0]==after_list[-1]:
#         return after_list[0]
# print(find_number(list))




#题目：12 个高矮不同的人,排成两排,每排必须是从矮到高排列,
# 而且第二排比对应的第一排的人高,问排列方式有多少种?
# def count(n):
#     if int(n/2) == 1:
#         return [1]
#     if int(n/2) == 2:
#         return [2, 3]
#     nlist=[]
#     for j in count(n-2):
#         nlist.extend(list(range(j+1,(2*int(n/2)))))
#     return nlist
# print(len(count(12)))
#
list=[1,3,0,5,-1,6]
nlist=sorted(list)
# print(nlist)
# x,y,z= 0,1,2
# def find_dt_range(list,x,y,z):
#     res=[list[x]]
#     dt1=list[y]-list[x]
#     dt2=list[z]-list[y]
#     if dt1==dt2:
#         nexadd=[list[y],list[z]]
#         res.extend([nexadd])
#         x, y, z = y, z, z + 1
#         find_dt_range(list,x,y,z)
#     else:
#         x, y, z = y, z, z + 1
#         find_dt_range(list, x, y, z)
#     return res
#
#
# find_dt_range(nlist,x,y,z)

#判断字符串是否为对称串
# str="abccba"
# def ys_str(str):
#     str1="".join(reversed(str))
#     return str1==str
# print(ys_str(str))

# 用递归的方法判断整数组a[N]是不是升序排列。
# arry=[1,2,3,4,2]
# def ys_rank(arry,i=0):
#     if i==len(arry)-2:
#         return  arry[i+1]>arry[i]
#     if arry[i+1]<arry[i]:
#         return False
#     else:
#         return ys_rank(arry,i+1)
# print(ys_rank(arry))

#编写反转字符串的程序，要求优化速度、优化空间。
# import time
# str="abcd"
#
# import numpy as np
# def resver_str(str):
#     str=np.array([i for i in str])
#     i=0
#     while i<int(len(str)/2):
#         str[i],str[len(str)-1-i]=str[len(str)-1-i],str[i]
#         i+=1
#     return "".join(str)
# def reverse1(str):
#  return str[::-1]
# #
# #查看运算速度
# start=time.clock()
# print(resver_str(str))

# reverse1(str)
# end=time.clock()
# print(end-start)
# print('----')
# start1=time.clock()
# print("".join(reversed(str)))
# end1=time.clock()
# print(end1-start1)
#一下为他人方法

# string = 'abcdefbdbdbfbdbfdb'
#
#
# def string_reverse1(string):
#     return string[::-1]
#
#
# def string_reverse2(string):
#     t = [i for i in string ]
#     l = len(t)
#     for i, j in zip(range(l - 1, 0, -1), range(l // 2)):
#         t[i], t[j] = t[j], t[i]
#     return "".join(t)
#
#
# def string_reverse3(string):
#     if len(string) <= 1:
#         return string
#     return string_reverse3(string[1:]) + string[0]
#
#
# from collections import deque
# def string_reverse4(string):
#     d = deque()
#     d.extendleft(string)
#     return ''.join(d)
#
#
# def string_reverse5(string):
#     # return ''.join(string[len(string) - i] for i in range(1, len(string)+1))
#     return ''.join(string[i] for i in range(len(string) - 1, -1, -1))
#
#
# def resver_str(str):#效果还可以
#     str=[i for i in str]
#     i=0
#     while i<int(len(str)/2):
#         str[i],str[len(str)-1-i]=str[len(str)-1-i],str[i]
#         i+=1
#     return "".join(str)

# import time
# start=time.clock()
# # print(string_reverse1(string))
# # print(string_reverse2(string))
# # print(string_reverse3(string))
# # print(string_reverse4(string))
# print(string_reverse5(string))
# # print(resver_str(string))
# end=time.clock()
# print(end-start)
#
# start1=time.clock()
# # print(string_reverse1(string))
# # print(string_reverse2(string))
# # print(string_reverse3(string))
# # print(string_reverse4(string))
# # print(string_reverse5(string))
# print(resver_str(string))
# end1=time.clock()
# print(end1-start1)
# i=100
# print((len(str(i))-len(str(i).strip('0'))))

#n!后面有多少个零
# def trailingZeros(n):
#     i=1
#     count=int(n/i/5)
#     while int(n/i/5)>=5:
#         # print(i)
#         i += 1
#         count=count+int(n/i/5)
#     return count
# print(trailingZeros(26))
a=[1,2,3]
b=[2,4]


# def rotateString(s, offset):
#     # write your code here
#
#         offset = offset % len(s)
#
#         if offset == 0:
#             return s
#         else:
#             return s[-offset:] + s[:(len(s) - offset)]
#
# print(rotateString("abcdefg",38))
# print(rotateString("abcdefg",37))

# import numpy as np
# def fizzBuzz( n):
#     arr = np.array(range(1, n + 1))
#     res = np.array(range(1, n + 1), dtype=np.str_)
#     res[arr[arr % 3 == 0][arr[arr % 3 == 0] % 5 == 0]] = "v"
#     res[arr % 3 == 0] = "f"
#     res[arr % 5 == 0] = "b"
#     rlist = res.tolist()
#     rest = str(rlist).replace("f", "fizz").replace("b", "buzz"). \
#         replace("v", "fizz buzz").replace("]", "").replace("[", "").replace("'", "")
#     return rest
# print(fizzBuzz(34))

# def fizzBuzz2( n):
#
#     res=[j for j in range(1,n+1)]
#     for i in range(len(res)):
#         if res[i]%3==0 and res[i]%5==0:
#             res[i]="fizz buzz"
#         elif res[i]%3==0:
#             res[i]="fizz"
#         elif res[i]%5==0:
#             res[i]="buzz"
#         else:
#             res[i]=str(res[i])
#     return res
# print(fizzBuzz2(160))

# def strStr(source, target):
#     # Write your code here
#     if target=="":
#         return  0
#     slit = source.split(target)
#
#     if len(slit) == 1:
#         return -1
#     elif len(slit) == len(source):
#         return 0
#     elif len(slit) > 1:
#         return len(slit[0])
# print(strStr("anv",""))

# def binarySearch(nums, target):
#     # write your code here
#     for i in range(len(nums)):
#         print(nums[i])
#         print(target)
#         if nums[-1]<target:
#             return  -1
#         if nums[i] < target:
#             continue
#         if nums[i] == target:
#             return i + 1
#         if nums[i]>target:
#             return -1
# print(binarySearch([1,2,3,4,5,8],60))
# print()
# nums=[1,2,3]
# # p=nums.pop(1)
# nums.insert(1,4)
# # print(p)
# print(1 not in nums)
# res=[]
# def find_chistr(nums):
#
#     print(nums)
#     res.append(nums)
#     for i in range(len(nums)):
#         p=nums.pop(i)
#         find_chistr(nums)
#         nums.insert(i, p)
# print(find_chistr([1,2,3]))
# print(res)


# class Solution:
#     def permute(self, nums):
#         """
#         :type nums: List[int]
#         :rtype: List[List[int]]
#         """
#         if len(nums) == 0:
#             return [nums]
#         results = []
#         for index in range(len(nums)):
#             for item in self.permute(nums[:index] + nums[index + 1:]):
#                 print(item)
#                 results.append([nums[index]] + item)
#
#         return results
# object = Solution()
# nums = [1, 2, 3]
# results = object.permute(nums)
# print(results)


#
# class Solution:
#     """
#     @param nums: A set of numbers
#     @return: A list of lists
#     """
#
#     def subsets(self, nums):
#         # write your code here
#         # print(nums)
#         nums = sorted(nums)
#         res = [nums]
#         for i in range(len(nums)):
#             for j in self.subsets(nums[:i] + nums[i + 1:]):
#                 if j not in res:
#                     res.append(j)
#
#         return res
#
# object = Solution()
# nums = [4,8,5]
# results = object.subsets(nums)
# print(results)

def subarraySum( nums):
    numst=nums[::-1]
    for i in range(1,len(nums)):
        for j in range(len(numst[1:i+1])):
            if sum(numst[j:i])==0:
                return [len(nums)-i,len(nums)+j-1]

# print(subarraySum([-3, 1, 2, -3, 4]))
# print(subarraySum([1,0,-1]))


def minPathSum( grid):
    f = [sum(grid[0][:i + 1]) for i in range(len(grid[0]))]
    for i in range(1,len(grid)):
        j=0
        while j<len(grid[i]):
            g = f
            if j ==0 :
                g[j]=f[j]+grid[i][j]

            else:
                g[j]=min(f[j]+grid[i][j],g[j-1]+grid[i][j])
            f=g
            j+=1

    return f[len(grid[0])-1]

grid=[[1,1,1],[20,20,9],[1,2,9],[1,1,1]]
# print(minPathSum(grid))


#爬楼梯
def climbStairs(n):
    if n<=2:
        return n
    res = []
    def dp(n):
        for i in range(n+1):
            if i <= 2:
                res.append(i)
            else:
                res.append(res[i - 2] + res[i - 1])
    dp(n)
    print(res)
    return res[n]
# print(climbStairs(4))

def uniquePaths(m,n):  #m*n网格通过方式数
    res=[[0 for i in range(n)] for j in range(m)]
    for i in range(m):
        if i==0:
            res[i] = [1 for i in range(n)]
        else:
            for j in range(n):
                if j ==0:
                    res[i][j] = 1
                else:
                    res[i][j]=res[i][j-1]+res[i-1][j]

    # print(res)
    return res[-1][-1]

# print(uniquePaths(10,12))
import math
def sqrt1(x):
        # write your code here
        if x==0:
            return 0
        s=x
        for i in range(10):
            s=(s+x/s)/2
        return math.floor(s)

# print(sqrt1(4187))
# print(math.sqrt(4187))

# print(bin(0)[3:])
def checkPowerOf2(n):
    str=[i for i in bin(n)[3:] if i !='0']
    print(str)
    if str ==[]:
        return True
    else:
        return  False

# print(checkPowerOf2(0))

intervals=[(1,3),(2,6),(8,10),(11,18)]
def merge(intervals,res):
    begin=intervals[0][0]
    end=intervals[0][1]
    for i in range(1,len(intervals)):
        if intervals[i][0]>intervals[i-1][1]:
            end=intervals[i-1][1]
            res.append((begin,end))
            begin=intervals[i][0]
    end=intervals[len(intervals)-1][1]
    res.append((begin, end))
    return res
# print(merge(intervals,[]))
# print(merge([(1,3)],[]))


def longestValidParentheses( s):
        # write your code here
        for i in range(len(s)):
            repl="("+"0"*i+")"
            s=s.replace(repl,"0"*(i+1))
        r=[]
        res=0
        for j in range(len(s)):
            if s[j]=="0":
                res+=1
            if s[j]!="0":
                r.append(res)
                res=0
        r.append(res)
        return  max(r)

# print(longestValidParentheses("()(()))"))
# print(longestValidParentheses(")()((())"))

l={'a': 2, 'b': 1, 'c': 2, 'd': 1, 'e': 1, 'f': 2}
# print([i for i in filter(lambda x:x,l)])
def firstUniqChar( str):
    # Write your code here
    res = {}
    for i in range(len(str)):
        if str[i] not in res:
            res[str[i]]=1
        else:
            res[str[i]]=res[str[i]]+1
    for j in res.items():
        if j[1]==1:
            return j[0]
        # print(j)

    # return res

# print(firstUniqChar("abaccdeff"))
def compress( originalString):  #字符串压缩
    # write your code here
    if originalString == "":
        return originalString
    i, j = 0, 0
    res = ''
    while i + j < len(originalString):
        if originalString[i] == originalString[i + j]:
            j += 1
        else:
            res = res + originalString[i] + str(j)
            i += j
            j = 0
    res = res + originalString[i] + str(j)

    if len(res) >= len(originalString):
        return originalString
    return res

# print(compress("aabcccccaaa"))
def addBinary( a, b):
    # write your code here
    a = int(a, 2)
    b = int(b, 2)
    s = a + b
    return bin(s)[2:]



def reverseInteger(self, n):
    # write your code here
    n = [i for i in str(n)]
    if n[0] != "-":
        nreversed = "".join(n[::-1]).lstrip("0")
        return int(nreversed)
    else:
        n = n[1:]
        nreversed = "".join(n[::-1]).lstrip("0")
        return int(nreversed)
def isNumber(s):
        # write your code here
        try:
            res=s.isdigit()
            return True
        except:
            print(type(s))
            return False

# print(isNumber("123"))
def countAndSay( n):

    if n == 1:
        return "1"
    if n == 2:
        return "11"
    if n>2:
        shuju=countAndSay( n-1)
        res=''
        j=1
        for i in range(1,len(shuju)):
            if shuju[i]==shuju[i-1]:
                j+=1
            if shuju[i]!=shuju[i-1]:
                res=res+str(j)+shuju[i-1]
                j=1
        else:
            res = res + str(j) + shuju[len(shuju)-1]
        # print(res)
        return res

# print(countAndSay(1))
# print(countAndSay(2))
# print(countAndSay(3))
# print(countAndSay(4))
# print(countAndSay(5))

def partitionArray(nums):
        # write your code here
        i, j = 0, len(nums) - 1
        while i < j:
            if nums[i] % 2 == 1:
                i += 1
            else:
                nums[i], nums[j] = nums[j], nums[i]
                j -= 1
        return nums
# print(partitionArray([1,2,3,4,5]))


def isValidSudoku(board):
    row = [set([]) for i in range(9)]
    col = [set([]) for i in range(9)]
    grid = [set([]) for i in range(9)]

    for r in range(9):
        for c in range(9):
            if board[r][c] == '.':
                continue
            if board[r][c] in row[r]:
                return False
            if board[r][c] in col[c]:
                return False

            g = 3 * (r // 3) + c // 3
            if board[r][c] in grid[g]:
                return False
            grid[g].add(board[r][c])
            row[r].add(board[r][c])
            col[c].add(board[r][c])
            print(col)

    return True
board=["....5..1.",".4.3.....",".....3..1","8......2.","..2.7....",".15......",".....2...",".2.9.....","..4......"]
colstr = ["".join(map(lambda x: x[i], board)) for i in range(len(board))]

# print(isValidSudoku(board))
A=[0,0]
B=[0,0]
def cosineSimilarity( A, B):
    # write your code here
    import math
    if A == [] :
        return 2
    fenzi = 0
    fenmua = 0
    fenmub = 0
    for i in range(len(A)):
        fenzi = fenzi + A[i] * B[i]
        fenmua = fenmua + A[i] ** 2
        fenmub = fenmub + B[i] ** 2
    if math.sqrt(fenmua) * math.sqrt(fenmub)==0:
        return 2
    similarity = fenzi / (math.sqrt(fenmua) * math.sqrt(fenmub))
    return similarity
# print(cosineSimilarity(A,B))


def findPosition(nums, target):
    # write your code here
    left, right = 0, len(nums) - 1
    mid=len(nums)//2
    while left<=right:

        if nums[mid] < target:
            left = mid + 1
            mid=(left+right)//2
        elif nums[mid] > target:
            right = mid - 1
            mid = (left + right) // 2
        else:
            return mid


# print(findPosition([1,2,2,4,5,5],1))
def isHappy( n):
        # write your code here
        try:
            if n==1:
                return True
            n=((n//100)**2)+((n//10)**2)
            return isHappy(n)
        except:
            return  False

# print(isHappy(18))

def isPalindrome(self, num):
    # write your code here
    # nums=str(num)[::-1]
    # return nums==str(num)

    nums = [int(i) for i in str(num)]
    length = len(nums)
    for i in range(length // 2):
        if nums[i] != nums[length - i]:
            return False
    return True

def numWays( n, k):
    res=[k,k*k]
    if n>2:
        for i in range(3,n):
            res.append(res[i-1]*(k-1)+res[i-2]*(k-1))
    return  res[-1]
# print(numWays(3,2))

def isUgly( num):
        # write your code here

        while 1:
            if num < 1:
                return False
            elif num % 2 == 0:
                num = num / 2
            elif num % 3 == 0:
                num = num / 3
            elif num % 5 == 0:
                num = num / 5
            elif num == 1:
                return True

            else:
                return False
# print(isUgly(12))


def moveZeroes( nums):
    # write your code here
    i = 0
    j=0
    while i+j < len(nums):
        if nums[i] == 0:
            nums.pop(i)
            nums.append(0)
            j+=1
        else:
            i += 1
        print(nums)
    return  nums
# print(moveZeroes([0,1,0,-2,0,0,1]))
def intersection( nums1, nums2):
        # write your code here
        res = []
        i, j = 0, 0
        while i<len(nums1):
            if nums1[i] != nums2[j]:
                j += 1
                if j>len(nums2)-1:
                    i+=1
                    j=0
            elif nums1[i] == nums2[j]:
                if nums2[j] not in res:
                    res.append(nums2[j])
                i += 1
                j = 0
        return res
# print(intersection([1,2,2,1], [2,2]))
def addDigits1( num,res):
    i = 1
    res = num%10
    while num // (10**i) > 0:
        numt = num // (10**i)
        print(numt)
        add = numt % 10
        res+=add
        i += 1
    if res < 10:
        return res
    else:
        return addDigits1(res,0)
print(addDigits1(9,0))
# print(111//10000)


s="1"
print(s.isdigit())